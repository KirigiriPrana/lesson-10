{"name": "test_change_data", "status": "broken", "statusDetails": {"message": "sqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is required for bind parameter 'company_id'\n[SQL: insert into employee (id, is_active\\, first_name, last_name, phone, company_id) values (DEFAULT, DEFAULT,(%(first_name)s, %(last_name)s, %(phone)s, %(company_id)s)]\n[parameters: [{'first_name': 'Иван', 'last_name': 'Петров', 'phone': '+79969598584', 'id_company': <bound method EmployerTable.get_max_id_comp of <EmployeDB.EmployerTable object at 0x000002145D7C8490>>}]]\n(Background on this error at: https://sqlalche.me/e/20/cd3x)", "trace": "self = <sqlalchemy.engine.base.Connection object at 0x000002145FF16950>\ndialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x000002145F95FA90>\nconstructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2'>>\nstatement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x000002145FAE3250>\nparameters = [{'first_name': 'Иван', 'id_company': <bound method EmployerTable.get_max_id_comp of <EmployeDB.EmployerTable object at 0x000002145D7C8490>>, 'last_name': 'Петров', 'phone': '+79969598584'}]\nexecution_options = immutabledict({})\nargs = (<sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x000002145FAE3250>, [{'first_name': 'Иван', 'id_company': ...type_=NullType()), BindParameter('last_name', None, type_=NullType()), BindParameter('phone', None, type_=NullType())])\nkw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}\nconn = <sqlalchemy.pool.base._ConnectionFairy object at 0x000002145FE782F0>\n\n    def _execute_context(\n        self,\n        dialect: Dialect,\n        constructor: Callable[..., ExecutionContext],\n        statement: Union[str, Compiled],\n        parameters: Optional[_AnyMultiExecuteParams],\n        execution_options: _ExecuteOptions,\n        *args: Any,\n        **kw: Any,\n    ) -> CursorResult[Any]:\n        \"\"\"Create an :class:`.ExecutionContext` and execute, returning\n        a :class:`_engine.CursorResult`.\"\"\"\n    \n        if execution_options:\n            yp = execution_options.get(\"yield_per\", None)\n            if yp:\n                execution_options = execution_options.union(\n                    {\"stream_results\": True, \"max_row_buffer\": yp}\n                )\n        try:\n            conn = self._dbapi_connection\n            if conn is None:\n                conn = self._revalidate_connection()\n    \n>           context = constructor(\n                dialect, self, conn, execution_options, *args, **kw\n            )\n\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\base.py:1819: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\default.py:1374: in _init_compiled\n    self.compiled_parameters = [\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\default.py:1375: in <listcomp>\n    compiled.construct_params(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x000002145FAE3250>\nparams = {'first_name': 'Иван', 'id_company': <bound method EmployerTable.get_max_id_comp of <EmployeDB.EmployerTable object at 0x000002145D7C8490>>, 'last_name': 'Петров', 'phone': '+79969598584'}\nextracted_parameters = [BindParameter('company_id', None, type_=NullType()), BindParameter('first_name', None, type_=NullType()), BindParameter('last_name', None, type_=NullType()), BindParameter('phone', None, type_=NullType())]\nescape_names = False, _group_number = 0, _check = True, _no_postcompile = False\n\n    def construct_params(\n        self,\n        params: Optional[_CoreSingleExecuteParams] = None,\n        extracted_parameters: Optional[Sequence[BindParameter[Any]]] = None,\n        escape_names: bool = True,\n        _group_number: Optional[int] = None,\n        _check: bool = True,\n        _no_postcompile: bool = False,\n    ) -> _MutableCoreSingleExecuteParams:\n        \"\"\"return a dictionary of bind parameter keys and values\"\"\"\n    \n        if self._render_postcompile and not _no_postcompile:\n            assert self._post_compile_expanded_state is not None\n            if not params:\n                return dict(self._post_compile_expanded_state.parameters)\n            else:\n                raise exc.InvalidRequestError(\n                    \"can't construct new parameters when render_postcompile \"\n                    \"is used; the statement is hard-linked to the original \"\n                    \"parameters.  Use construct_expanded_state to generate a \"\n                    \"new statement and parameters.\"\n                )\n    \n        has_escaped_names = escape_names and bool(self.escaped_bind_names)\n    \n        if extracted_parameters:\n            # related the bound parameters collected in the original cache key\n            # to those collected in the incoming cache key.  They will not have\n            # matching names but they will line up positionally in the same\n            # way.   The parameters present in self.bind_names may be clones of\n            # these original cache key params in the case of DML but the .key\n            # will be guaranteed to match.\n            if self.cache_key is None:\n                raise exc.CompileError(\n                    \"This compiled object has no original cache key; \"\n                    \"can't pass extracted_parameters to construct_params\"\n                )\n            else:\n                orig_extracted = self.cache_key[1]\n    \n            ckbm_tuple = self._cache_key_bind_match\n            assert ckbm_tuple is not None\n            ckbm, _ = ckbm_tuple\n            resolved_extracted = {\n                bind: extracted\n                for b, extracted in zip(orig_extracted, extracted_parameters)\n                for bind in ckbm[b]\n            }\n        else:\n            resolved_extracted = None\n    \n        if params:\n            pd = {}\n            for bindparam, name in self.bind_names.items():\n                escaped_name = (\n                    self.escaped_bind_names.get(name, name)\n                    if has_escaped_names\n                    else name\n                )\n    \n                if bindparam.key in params:\n                    pd[escaped_name] = params[bindparam.key]\n                elif name in params:\n                    pd[escaped_name] = params[name]\n    \n                elif _check and bindparam.required:\n                    if _group_number:\n                        raise exc.InvalidRequestError(\n                            \"A value is required for bind parameter %r, \"\n                            \"in parameter group %d\"\n                            % (bindparam.key, _group_number),\n                            code=\"cd3x\",\n                        )\n                    else:\n>                       raise exc.InvalidRequestError(\n                            \"A value is required for bind parameter %r\"\n                            % bindparam.key,\n                            code=\"cd3x\",\n                        )\nE                       sqlalchemy.exc.InvalidRequestError: A value is required for bind parameter 'company_id' (Background on this error at: https://sqlalche.me/e/20/cd3x)\n\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\sql\\compiler.py:1894: InvalidRequestError\n\nThe above exception was the direct cause of the following exception:\n\n    def test_change_data():\n        db.create_company('Моя компания')\n        max_id_c = db.get_max_id_comp\n    \n        name_emp = 'Иван'\n        la_name = 'Петров'\n        phone_num = '+79969598584'\n    \n>       db.create_employer(name_emp, la_name, phone_num, max_id_c)\n\n..\\lesson_9\\test_list_of_employee.py:81: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nEmployeDB.py:57: in create_employer\n    result = connection.execute(self.scripts[\"create_employer\"],\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\base.py:1422: in execute\n    return meth(\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\sql\\elements.py:514: in _execute_on_connection\n    return connection._execute_clauseelement(\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\base.py:1644: in _execute_clauseelement\n    ret = self._execute_context(\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\base.py:1825: in _execute_context\n    self._handle_dbapi_exception(\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\base.py:2357: in _handle_dbapi_exception\n    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\base.py:1819: in _execute_context\n    context = constructor(\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\default.py:1374: in _init_compiled\n    self.compiled_parameters = [\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\engine\\default.py:1375: in <listcomp>\n    compiled.construct_params(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x000002145FAE3250>\nparams = {'first_name': 'Иван', 'id_company': <bound method EmployerTable.get_max_id_comp of <EmployeDB.EmployerTable object at 0x000002145D7C8490>>, 'last_name': 'Петров', 'phone': '+79969598584'}\nextracted_parameters = [BindParameter('company_id', None, type_=NullType()), BindParameter('first_name', None, type_=NullType()), BindParameter('last_name', None, type_=NullType()), BindParameter('phone', None, type_=NullType())]\nescape_names = False, _group_number = 0, _check = True, _no_postcompile = False\n\n    def construct_params(\n        self,\n        params: Optional[_CoreSingleExecuteParams] = None,\n        extracted_parameters: Optional[Sequence[BindParameter[Any]]] = None,\n        escape_names: bool = True,\n        _group_number: Optional[int] = None,\n        _check: bool = True,\n        _no_postcompile: bool = False,\n    ) -> _MutableCoreSingleExecuteParams:\n        \"\"\"return a dictionary of bind parameter keys and values\"\"\"\n    \n        if self._render_postcompile and not _no_postcompile:\n            assert self._post_compile_expanded_state is not None\n            if not params:\n                return dict(self._post_compile_expanded_state.parameters)\n            else:\n                raise exc.InvalidRequestError(\n                    \"can't construct new parameters when render_postcompile \"\n                    \"is used; the statement is hard-linked to the original \"\n                    \"parameters.  Use construct_expanded_state to generate a \"\n                    \"new statement and parameters.\"\n                )\n    \n        has_escaped_names = escape_names and bool(self.escaped_bind_names)\n    \n        if extracted_parameters:\n            # related the bound parameters collected in the original cache key\n            # to those collected in the incoming cache key.  They will not have\n            # matching names but they will line up positionally in the same\n            # way.   The parameters present in self.bind_names may be clones of\n            # these original cache key params in the case of DML but the .key\n            # will be guaranteed to match.\n            if self.cache_key is None:\n                raise exc.CompileError(\n                    \"This compiled object has no original cache key; \"\n                    \"can't pass extracted_parameters to construct_params\"\n                )\n            else:\n                orig_extracted = self.cache_key[1]\n    \n            ckbm_tuple = self._cache_key_bind_match\n            assert ckbm_tuple is not None\n            ckbm, _ = ckbm_tuple\n            resolved_extracted = {\n                bind: extracted\n                for b, extracted in zip(orig_extracted, extracted_parameters)\n                for bind in ckbm[b]\n            }\n        else:\n            resolved_extracted = None\n    \n        if params:\n            pd = {}\n            for bindparam, name in self.bind_names.items():\n                escaped_name = (\n                    self.escaped_bind_names.get(name, name)\n                    if has_escaped_names\n                    else name\n                )\n    \n                if bindparam.key in params:\n                    pd[escaped_name] = params[bindparam.key]\n                elif name in params:\n                    pd[escaped_name] = params[name]\n    \n                elif _check and bindparam.required:\n                    if _group_number:\n                        raise exc.InvalidRequestError(\n                            \"A value is required for bind parameter %r, \"\n                            \"in parameter group %d\"\n                            % (bindparam.key, _group_number),\n                            code=\"cd3x\",\n                        )\n                    else:\n>                       raise exc.InvalidRequestError(\n                            \"A value is required for bind parameter %r\"\n                            % bindparam.key,\n                            code=\"cd3x\",\n                        )\nE                       sqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is required for bind parameter 'company_id'\nE                       [SQL: insert into employee (id, is_active\\, first_name, last_name, phone, company_id) values (DEFAULT, DEFAULT,(%(first_name)s, %(last_name)s, %(phone)s, %(company_id)s)]\nE                       [parameters: [{'first_name': 'Иван', 'last_name': 'Петров', 'phone': '+79969598584', 'id_company': <bound method EmployerTable.get_max_id_comp of <EmployeDB.EmployerTable object at 0x000002145D7C8490>>}]]\nE                       (Background on this error at: https://sqlalche.me/e/20/cd3x)\n\n..\\..\\..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\sqlalchemy\\sql\\compiler.py:1894: StatementError"}, "start": 1716204576661, "stop": 1716204577282, "uuid": "29c7e782-3a66-4d09-9dd2-f91351915a44", "historyId": "1db14420f37c9e418bcaef62911c45b3", "testCaseId": "1db14420f37c9e418bcaef62911c45b3", "fullName": "test_list_of_employee#test_change_data", "labels": [{"name": "suite", "value": "test_list_of_employee"}, {"name": "host", "value": "LAPTOP-AF2L46GU"}, {"name": "thread", "value": "19436-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_list_of_employee"}]}